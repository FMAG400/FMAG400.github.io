<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux</title>
    <url>/2021/03/21/Linux/</url>
    <content><![CDATA[<h3 id="文件基本属性指令"><a href="#文件基本属性指令" class="headerlink" title="文件基本属性指令"></a>文件基本属性指令</h3><hr>
<ol>
<li>chmod - 更改文件属性 owner/group/others , rwx-rwx-rwx , 4+2+1/4+2+1/4+2+1 = 777. <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># -rw-r--r-- 开头 - 表示file</span><br><span class="line"># drw-r--r-- 开头 d 表示目录</span><br><span class="line">chmod [-R] 777 文件或目录</span><br></pre></td></tr></tbody></table></figure></li>
<li>chown - 更改文件属主/组.<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 改变当前文件的拥有者/群组</span><br><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="路径的区别"><a href="#路径的区别" class="headerlink" title="路径的区别"></a>路径的区别</h3><hr>
<ol>
<li>绝对路径 - /user/Desktop/directory1</li>
<li>相对路径 - 假设当前处于directory1这个目录, 那么可以通过 ../Desktop 回到directory1的上一目录, 因为 .. 表示上一级</li>
</ol>
<h3 id="处理目录基本指令"><a href="#处理目录基本指令" class="headerlink" title="处理目录基本指令"></a>处理目录基本指令</h3><hr>
<ol>
<li>绝对路径</li>
<li>相对路径</li>
</ol>
<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><hr>
<ol>
<li>cat - 从第一行显示文件</li>
<li>more file_name - 一页一页的显示</li>
<li>head number file_name - 只看头几行</li>
<li>tail number fil_name - 只看尾几行</li>
</ol>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><hr>
<ol>
<li>/word - 搜索关键字</li>
<li>dd - 删除游标所在行</li>
<li>d$ - 删除游标及所在行往后的字符</li>
<li>u - 复原前一个动作</li>
<li>. - 重复前一个动作</li>
<li>set nu/nonu - 显示行号/不显示</li>
<li>5,7s/^#//#g - 添加//到5,7行</li>
<li>6,8s/^//##g - 删除//</li>
<li>5,6s/^/#/g - 添加#</li>
<li>5,6s/#//g - 删除#</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/03/20/Mysql/</url>
    <content><![CDATA[<h2 id="MySQL-WorkBench"><a href="#MySQL-WorkBench" class="headerlink" title="MySQL WorkBench"></a>MySQL WorkBench</h2><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><hr>
<ol>
<li>常规执行命令, mac: cmd + return, win: ctrl + enter</li>
<li>像CREAT, UPDATE, DELETE这些命令的指令需要这样, mac: cmd + shift + return, win: ctrl + shift + return, 并且UPDATE和DELETE还需要关闭安全模式才能执行.</li>
</ol>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><hr>
<ol>
<li>数值类型<ul>
<li>INT/INTEGER – 4 bytes (-, 2147483647) (4294967295)</li>
<li>FLOAT – 4 bytes</li>
<li>DOUBLE – 8 bytes</li>
<li>DECIMAL(M,D) – 如果M&gt;D, M+2, D+2</li>
</ul>
</li>
<li>字符串类型<ul>
<li>VARCHAR(25) – Uses up to 25 + 1 bytes. 0-65535 bytes.</li>
<li>CHAR – 0-255 bytes</li>
<li>TEXT – 0-65535 bytes</li>
</ul>
</li>
<li>日期和时间<ul>
<li>DATE – 3 bytes, YYYY-MM-DD</li>
<li>TIME – 3 bytes, HH:MM:SS</li>
<li>YEAR – 1 bytes, YYYY</li>
<li>DATETIME – YYYY-MM-DD HH:MM:SS</li>
</ul>
</li>
</ol>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><hr>
<ol>
<li>Line oriented comment(two hyphen characters): <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Album; <span class="comment">-- this is a comment</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>Multi line comments: <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Album;</span><br></pre></td></tr></tbody></table></figure>


</li>
</ol>
<h3 id="设置显示行数"><a href="#设置显示行数" class="headerlink" title="设置显示行数"></a>设置显示行数</h3><hr>
<p>FROM 表后使用</p>
<ol>
<li>LIMIT 5 - 只显示前五行</li>
<li>LIMIT 5,5 - 第一个五表示显示5行, 第二个5表示跳过5行后再显示。</li>
</ol>
<h3 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h3><hr>
<ol>
<li>SHOW DATABASE; – 显示当前所有存在的数据库名字.</li>
<li>USE Scratch; SHOW tables; – 展示Scratch这个数据库里面所有的table名字.</li>
<li>DESCRIBE customer; –  展示customer这个table里面的所有列明和类型等.</li>
<li>SHOW TABLE STATUS; – 展示所有表格的行数列数等基本信息.</li>
<li>SHOW CREATE TABLE table_name; – 展示创建这个表格的基本语句.</li>
</ol>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><hr>
<ol>
<li>CREATE TABLE table_name (column_name1 type, …);<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">    a <span class="type">INT</span> UNSIGNED <span class="keyword">UNIQUE</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">    b <span class="type">VARCHAR</span>(<span class="number">16</span>), </span><br><span class="line">    c <span class="type">VARCHAR</span>(<span class="number">16</span>), <span class="comment">-- 创建列名和类型并初始化空间大小.</span></span><br><span class="line">    d ENUM(<span class="string">'new'</span>, <span class="string">'old'</span>) <span class="comment">-- new 的索引是1, old 的索引是2</span></span><br><span class="line">    e <span class="keyword">SET</span>(<span class="string">'fish'</span>, <span class="string">'dog'</span>, <span class="string">'cat'</span>) <span class="comment">-- 索引值依次是1,2,4,8...最多64</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">'this'</span>, <span class="string">'right here!'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">'that'</span>, <span class="string">'over there!'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">'another'</span>, <span class="string">'nowhere'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="string">'again'</span>, <span class="string">'guess where?'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="string">'one more'</span>, <span class="string">'everywhere!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (a) <span class="keyword">VALUES</span>(<span class="number">1</span>); <span class="comment">-- ENUM 往a这个列里'new'</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (a) <span class="keyword">VALUES</span>(<span class="number">2</span>); <span class="comment">-- ENUM 往a这个列里添加'old'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (a) <span class="keyword">VALUES</span>(<span class="number">1</span>); <span class="comment">-- SET 1 往a这个列里'fish'</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (a) <span class="keyword">VALUES</span>(<span class="number">2</span>); <span class="comment">-- SET 2 往a这个列里'dog'</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (a) <span class="keyword">VALUES</span>(<span class="number">3</span>); <span class="comment">-- SET 1 + 2 往a这个列里'fish dog'</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (a) <span class="keyword">VALUES</span>(<span class="number">4</span>); <span class="comment">-- SET 4 往a这个列里'cat'</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (a) <span class="keyword">VALUES</span>(<span class="number">5</span>); <span class="comment">-- SET 1 + 4 往a这个列里'fish cat'</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (a) <span class="keyword">VALUES</span>(<span class="number">6</span>); <span class="comment">-- SET 2 + 4 往a这个列里'dog cat'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (c) <span class="keyword">VALUES</span>(<span class="string">'new one'</span>); <span class="comment">-- 也可以在指定的列名下面添加东西.</span></span><br></pre></td></tr></tbody></table></figure>
若当前创建的表已存在, 咋不会进行改变.<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> countries (country_id <span class="type">varchar</span>(<span class="number">2</span>), country_name <span class="type">VARCHAR</span>(<span class="number">20</span>), region_id <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><hr>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name; <span class="comment">-- 无论表内有没有数据</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="向表内添加数据"><a href="#向表内添加数据" class="headerlink" title="向表内添加数据"></a>向表内添加数据</h3><hr>
<ol>
<li>按照表格的数据类型添加数据INSERT INTO table_name (column_name,…) VALUES (….)<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customer (name, address, city, state, zip) <span class="keyword">VALUES</span> (<span class="string">'Fred Flinstone'</span>, <span class="string">'123 Cobblestone Way'</span>, <span class="string">'Bedrock'</span>, <span class="string">'CA'</span>, <span class="string">'91234'</span>); <span class="comment">-- 往customer这个表里面添加数据</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="更新表内容"><a href="#更新表内容" class="headerlink" title="更新表内容"></a>更新表内容</h3><hr>
<ol>
<li>UPDATE table_name SET column_name1 = ‘’, column_name2 = ‘’ WHERE …<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES<span class="operator">=</span><span class="number">0</span>; <span class="comment">-- 禁用安全更新模式后可对表格进行更新操作.</span></span><br><span class="line"><span class="keyword">UPDATE</span> customer <span class="keyword">SET</span> address <span class="operator">=</span> <span class="string">'123 Music Avenue'</span>, zip <span class="operator">=</span> <span class="string">'98056'</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">'Jimi%'</span>;</span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- 启用安全更新模式, 为了防止例如向删除操作时, 忘记添加 WHERE 指定位置的话会造成一些不必要的麻烦等. </span></span><br></pre></td></tr></tbody></table></figure></li>
<li>注意执行命令需要 mac: cmd+shift+return win: ctrl+shift+enter, 并且需要改变</li>
</ol>
<h3 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h3><hr>
<ol>
<li>修改字段类型 - MODIFY,CHANGE<ul>
<li>ALTER TABLE table_name MODIFY column_name type defult; – 修改字段类型</li>
<li>ALTER TABLE table_name CHANGE column_name new_column_name type defult; – 修改字段类型, 并且要更改字段原来的命名.</li>
</ul>
</li>
<li>删除, 添加或修改表字段 - DROP,ADD<ul>
<li>ALTER TABLE table_name DROP column_name1; – 删除表内的某个字段.</li>
<li>ALTER TABLE table_name ADD column_name1 INT; – 向表内添加某个字段.</li>
<li>ALTER TABLE table_name ADD column_name1 INT FIRST; – 向表内添加字段并且指定位置.</li>
</ul>
</li>
</ol>
<h3 id="CHECK-检查约束"><a href="#CHECK-检查约束" class="headerlink" title="CHECK 检查约束"></a>CHECK 检查约束</h3><hr>
<ol>
<li>创建表时, 判断插入max_salary的值是否小于25000.<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">max_salary <span class="type">decimal</span>(<span class="number">6</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">CHECK</span>(max_salary <span class="operator">&lt;=</span> <span class="number">25000</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li>创建表后, 若想修改约束则使用ALTER<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">CHECK</span>( ... );</span><br></pre></td></tr></tbody></table></figure></li>
<li>删除约束<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> constraint_name;</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="删除表内容"><a href="#删除表内容" class="headerlink" title="删除表内容"></a>删除表内容</h3><hr>
<ol>
<li>DELETE FROM table_name WHERE …<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customer <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">'Jimi%'</span> <span class="keyword">OR</span> name <span class="keyword">LIKE</span> <span class="string">'Fred%'</span>; <span class="comment">-- 删除customer这个表格里, 名字以Jimi和Fred开头的所有人的数据.</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="IF-表达式"><a href="#IF-表达式" class="headerlink" title="IF 表达式"></a>IF 表达式</h3><hr>
<ol>
<li>IF(b&gt;0, ‘true’, ‘false’) FROM booltest; – 如果b&gt;0, 返回true, 反之false.</li>
</ol>
<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><hr>
<ol>
<li>LIKE ‘a%’ – 表示以a开头的</li>
<li>RLIKE ‘y$’ – 表示以y结尾的</li>
<li>RLIKE ‘[xy][ij]’ – 表示x或y的后面跟着i或j</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><hr>
<ol>
<li>CONCAT(‘1’,’2’) – 把元素连接起来 -&gt; 12.</li>
<li>OCT(num), HEX(num), BIN(num), CONV(num, 10, 16) – 把num base 10 to be 16.</li>
<li>TRIM(‘  b   ‘) – 去掉b前后的空格 , 同理 LTRIM, RTRIM.</li>
<li>UPPER(name) = UCASE(),  LOWER(name) = LCASE(name),</li>
<li>SUBSTRING(‘this is a string’, 6) – 从第六个位置开始往后的字符. <ul>
<li>SUBSTRING(‘this is a string’, 6, 4) –  从第六个位置开始往后的4个字符.</li>
<li>SUBSTRING(‘this is a string’, -6) – 从后往前数6个位置. </li>
</ul>
</li>
<li>SUBSTRING_INDEX(‘this is a string’, ‘’,1) – 碰到第一个分隔符‘’前的字符, this. </li>
<li>ABS(-45) – 绝对值45.</li>
<li>CEILING(12.2) – 13上界.FLOOR(12.6) - 12下界.</li>
<li>TRUNCATE(42.973, 1) –保留一位小数42.9</li>
<li>SQRT(16) – 4开方.</li>
</ol>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><hr>
<ol>
<li><p>Index 的用处</p>
<ul>
<li>Rapid lookup</li>
<li>Enforcing constraints</li>
<li>Ordered queries</li>
</ul>
</li>
<li><p>SHOW INDEX FROM table_name; – 展示当前table的键名.</p>
</li>
<li><p>CREATE INDEX index_name ON table_name(column_name); – 把table_name这个表里面的column_name命名为index_name的键.</p>
</li>
<li><p>DROP INDEX index_name ON table_name; – 删除table_name里面的index.</p>
</li>
</ol>
<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><hr>
<ol>
<li>CREATE VIEW view_name AS SELECT … – 创建了一个名为view_name的表格等于SELECT下面执行后的表格.</li>
<li>DROP VIEW IF EXISTS view_name; – 删除view</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><hr>
<ol>
<li><p>INSERT IGNORE</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> ignore <span class="keyword">INTO</span> names(name, age) <span class="keyword">VALUES</span>("大壮", <span class="number">25</span>); </span><br><span class="line"><span class="comment">-- Query OK, 0 rows affected, 1 warning (0.00 sec)</span></span><br><span class="line"><span class="comment">-- 如果当前插入已存在, 则忽略新插入的记录, id会自增, 不会报错.</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>INSERT</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> names(name, age) <span class="keyword">values</span>("小明", <span class="number">23</span>);</span><br><span class="line"><span class="comment">-- ERROR 1062 (23000): Duplicate entry '小明' for key 'name'</span></span><br><span class="line"><span class="comment">-- 若插入已存在则显示不成功.</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="Stored-Routines"><a href="#Stored-Routines" class="headerlink" title="Stored Routines"></a>Stored Routines</h3><hr>
<ol>
<li>stored function</li>
<li>stored procedure</li>
</ol>
<h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><h3 id="Trigger-触发器"><a href="#Trigger-触发器" class="headerlink" title="Trigger 触发器"></a>Trigger 触发器</h3><hr>
<h3 id="正则表达-REGEXP"><a href="#正则表达-REGEXP" class="headerlink" title="正则表达 REGEXP"></a>正则表达 REGEXP</h3><hr>
<ol>
<li>‘…’ 匹配包含的任意一个字符</li>
</ol>
<h3 id="数据表之间的连接"><a href="#数据表之间的连接" class="headerlink" title="数据表之间的连接"></a>数据表之间的连接</h3><hr>
<p>相比较于WHERE的条件过滤, JOIN能够在匹配的情况下完全保留别的信息.</p>
<ol>
<li>INNER JOIN – 内连接(等值连接),只取两表共同的数据</li>
<li>LEFT JOIN – 左连接, 取左边数据表所有的数据即便右边表没有对应的字段值</li>
<li>RIGHT JOIN – 右连接, 取右边数据表所有的数据即便左边表没有对应的字段值</li>
</ol>
<h3 id="判断当前目标是否为空"><a href="#判断当前目标是否为空" class="headerlink" title="判断当前目标是否为空"></a>判断当前目标是否为空</h3><hr>
<ol>
<li>IFNULL(expression, alt_value) – 当expression为NULL时, 返回第二个参数。</li>
</ol>
<h3 id="LIMIT的使用"><a href="#LIMIT的使用" class="headerlink" title="LIMIT的使用"></a>LIMIT的使用</h3><hr>
<ol>
<li>LIMIT 9,4 – 表示从第十行开始选取4行, 10，11，12，13</li>
<li>LIMIT 4 OFFSET 9 – 和上述一样</li>
</ol>
<h3 id="排名"><a href="#排名" class="headerlink" title="排名"></a>排名</h3><hr>
<ol>
<li>DENSE_RANK() OVER – 当遇到相同数字时排名一样, 当遇到一个不同的数字时 “排名连续”.即1,1,1,2,3,4,5,5,6<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Score, <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span>) <span class="string">'Rank'</span></span><br><span class="line"><span class="keyword">FROM</span> Scores; </span><br></pre></td></tr></tbody></table></figure></li>
<li>ROW_NUMBER() OVER – 从头到尾依次排名, 不区分是否相等.<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Score, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span>) <span class="string">'Rank'</span></span><br><span class="line"><span class="keyword">FROM</span> Scores; </span><br></pre></td></tr></tbody></table></figure></li>
<li>RANK() OVER – 当遇到相同数字时排名一样, 当遇到一个不同的数字时 “排名 不！连续”. 即可能 1,1,4,4,5,6<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Score, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span>) <span class="string">'Rank'</span></span><br><span class="line"><span class="keyword">FROM</span> Scores;</span><br></pre></td></tr></tbody></table></figure></li>
<li>leetcode - 数据库176, 177, 178, 184</li>
</ol>
<h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><hr>
<ol>
<li>对字段进行分组, </li>
</ol>
<h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><hr>
<ol>
<li>因为WHERE关键字无法与合计函数一起使用, 所以需要用到HAVING</li>
</ol>
<h3 id="UNION-UNION-ALL"><a href="#UNION-UNION-ALL" class="headerlink" title="UNION/ UNION ALL"></a>UNION/ UNION ALL</h3><hr>
<ol>
<li>UNION 操作符用于合并两个或多个 SELECT 语句的结果集.</li>
<li>请注意, UNION 内部的 SELECT 语句必须拥有相同数量的列. 列也必须拥有相似的数据类型. 同时, 每条 SELECT 语句中的列的顺序必须相同.</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/03/07/Git/</url>
    <content><![CDATA[<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><hr>
<ol>
<li>本地仓库由三部分组成, 工作区域，暂存区域(想象)和Git仓库.</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><hr>
<ol>
<li>git add <file>  <ul>
<li>把文件加入到<strong>暂存区</strong>, 而git restore –staged <file>是把文件从<strong>暂存区</strong>取回.</file></li>
</ul>
</file></li>
<li>git commit -m “word”   <ul>
<li>把文件提交到<strong>仓库</strong>.</li>
</ul>
</li>
<li>git status <ul>
<li>查看文件当前状态, 是否已暂存已修改或已被跟踪.</li>
</ul>
</li>
<li>git log <ul>
<li>查看修改记录.</li>
</ul>
</li>
<li>git diff <ul>
<li>比较暂存区和工作目录的文件(左暂存/右工作目录), 查看文件改动, 而git diff –staged/–cached 比较的是暂存区和仓库的区别. 或者diff 快照1/快照2</li>
</ul>
</li>
<li>git mv old_file new_file <ul>
<li>改文件名, 终端无消息显示.</li>
</ul>
</li>
<li>git reset HEAD~ <ul>
<li>回到上一个快照</li>
</ul>
</li>
<li>git reset 快照号 <ul>
<li>能够恢复到’未来’</li>
</ul>
</li>
<li>git commit –amend -m “ “<ul>
<li>“新的提交说明” – 修改最近的一次提交 </li>
</ul>
</li>
<li>git rm file_name <ul>
<li>– rm 命令删除的只是工作目录和暂存区域的文件.(即取消跟踪，在下次提交时不纳入版本管理)</li>
</ul>
</li>
<li>git rm -f file_name <ul>
<li>–指把工作目录和缓存区的文件都删掉.</li>
</ul>
</li>
<li>git rm –cached file_name <ul>
<li>–指单把缓存区的内容删掉.</li>
</ul>
</li>
</ol>
<div align="center"><img src="/images/git.png"></div>


<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><hr>
<p>实际开发中的分支分为:</p>
<ul>
<li>master - 主线, 用于发布</li>
<li>Hotfix - 修复bug</li>
<li>Release - 内部发布版本</li>
<li>Develop - 进行开发, 生成可执行程序给Release</li>
<li>Feature - 具体功能</li>
</ul>
<ol>
<li><strong>创建分支</strong><br>默认分支为master, 如果我们需要对主程序进行修改, 后期添加新的功能, 我们可以创建新的分支, 待功能开发完毕后再把分支合并到主程序中.<ul>
<li>git branch <branch name=""> 创建新的分支.</branch></li>
<li>git checkout <branch name=""> 分支切换, HEAD指向新的分支, 创建新的分支后, git log只能看到当前分支下的所有记录. git checkout -b <branch name=""> 能够同时创建新的分支, 并且HEAD指向新的分支.</branch></branch></li>
<li>git log –decorate –oneline –graph –all 能看到当前仓库的所有分支及HEAD指向, 还有版本信息.</li>
</ul>
</li>
<li><strong>合并分支</strong><br>把分支合并到主线里.<ul>
<li>git merge <branch name=""> 把当前分支合并到HEAD所指向的分支(master 主线).</branch></li>
</ul>
</li>
<li><strong>删除分支</strong><br>为了使整个开发看起来更加清晰明了, 那么一些不必要的分支需要被删除.<br>git branch -d <branch name=""></branch></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Sorted Algorithms</title>
    <url>/2021/03/13/Sorted%20Algorithm/</url>
    <content><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr>
<ol>
<li>方法1, 递归, 最好复杂度为<strong>O(nlogn)</strong>, 最坏为<strong>O(n^2)</strong> - 当数组是有序的时候,那么需要和临近的元素交换的话就和冒泡排序一样了. 首先需要做的是: <ul>
<li>(1) 选取给定数组的左或右两边的值作为数组的分割点<strong>pivot</strong>, 这个点的作用是第一次分割完成后的数组最后表示的是pivot左边的数都比它小, 右边的数都比它大. </li>
<li>(2) 设置<strong>left = 0</strong>和<strong>right = len(array) - 1</strong>两个指针, 如果(1)中选取左边的数为pivot, 那么需要right先判断, 反之相反. right指针的作用是找到比pivot小的数然后停留等待, 接着是left开始判断, left需要找比pivot大的数, 如果比pivot小那么left往右移1个位置, 直到找到比pivot大的数然后如果当前left还是在right的左边的话, 那么就把array[left]和array[right]进行交换. 这样可以节省时间比起冒泡排序的相邻交换。</li>
<li>(3) 当left和right相等时则代表这个位置就是该放置pivot了, 那么需要把当前值放到pivot的左边(因为这个值比pivot小), 然后pivot放到left和right相等的位置.</li>
<li>(4) 最后做重复操作, 递归调用函数, 单独取出pivot左边的数组和pivot右边的数组来分开排序和之前的操作一样.<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">nums, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        low = left  </span><br><span class="line">        high = right</span><br><span class="line">        pivot = nums[low]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># right指针从后往前判断比pivot小的数, 停留在比pivot小的位置</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt;= pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># left指针从后往前判断比pivot大的数, 停留在比pivot大的位置</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt;= pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果未完成判断, 那么就把左右两边的数调换</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                temp = nums[left]</span><br><span class="line">                nums[left] = nums[right]</span><br><span class="line">                nums[right] = temp</span><br><span class="line">        <span class="comment"># 最后把pivot换到分割的位置上</span></span><br><span class="line">        nums[low] = nums[right]   <span class="comment"># pivot最后交换的位置就是left==right</span></span><br><span class="line">        nums[right] = pivot</span><br><span class="line"></span><br><span class="line">        quicksort(nums, low, left-<span class="number">1</span>)</span><br><span class="line">        quicksort(nums, left + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li>方法2, 一趟循环. 假设pivot被设置为数组最右边的数, 那么该方法重点就是设置一个i = -1指针在数组最左边的外面, 主要用于找到比pivot大的数然后停留等待被交换, for循环从左往右依次判断当前数是否比pivot小, 如果小的话那么i往右移, 并且把array[i]和array[j]的值进行交换. 不断进行相同的操作直到循环结束, 最后i停留在比pivot大或等于的数的位置, 然后把pivot和这个位置的值进行交换, 最终可以找到pivot的下标位置, 然后返回给quick_sort()让其可以根据这个下标把数组进行切分. <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right:</span><br><span class="line">            p = partition(nums, left, right)</span><br><span class="line">            quick_sort(nums, left, p - <span class="number">1</span>)</span><br><span class="line">            quick_sort(nums, p + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">nums, left, right</span>):</span></span><br><span class="line">    pivot = nums[right]</span><br><span class="line">    i = left - <span class="number">1</span> <span class="comment"># 定位比pivot大的数, 记录位置然后进行调换</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right): <span class="comment"># pivot不需要考虑, 因此遍历范围小1</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i] <span class="comment"># 把比pivot大的都先跟比pivot小的数进行交换</span></span><br><span class="line">    nums[i + <span class="number">1</span>], nums[right] = nums[right], nums[i + <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span> <span class="comment">#返回分割点的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> quick_sort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<p>算法思想简单, 即从左往右依次两两比较, 如果前者比后者大就进行对换. <strong>len(nums) - 1 - i</strong>代表后面的数已不需要比较, 因为比前面的数要大.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span> - i):</span><br><span class="line">        <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">            nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line"><span class="keyword">return</span> nums</span><br></pre></td></tr></tbody></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<ol>
<li>分而治之, 把数组不断的划分到最后长度为1的数组, 然后开始比较数组中第一个数的大小, 最后合并返回. 注意奇数情况下的数组合并merge()时需要把多余的那部分加上. <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divid</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    left = divid(nums[:mid])</span><br><span class="line">    right = divid(nums[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]:</span><br><span class="line">            result.append(left.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:   </span><br><span class="line">            result.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">if</span> left:</span><br><span class="line">        result += left</span><br><span class="line">    <span class="keyword">elif</span> right:</span><br><span class="line">        result += right</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(divid(nums)) </span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<ol>
<li>堆是一种完全二叉树(除最后一层外, 其他层次的节点都达到最大个数,并且最后一层的所有节点都集中在左边). 另外, 堆又分为<ul>
<li>大顶堆 - root节点比子节点都大</li>
<li>小顶堆 - root节点比子节点都小</li>
</ul>
</li>
</ol>
<p>假设根据数组[4,6,7,2,9,8,3,5]构造大顶堆, 那么首先需要每个非叶子节点都跟它的左右子节点比较, 把最大值换到这个子树的root. 因为叶子节点无子节点, 所以都是从非叶子节点开始. 非叶子节点一般是数组里面的前<strong>len(array) // 2 - 1</strong>个数.</p>
<pre><code><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span>(<span class="params">heap, heap_size, root</span>):</span></span><br><span class="line">    <span class="comment"># 左右节点的位置即在数组中的下标</span></span><br><span class="line">    left_node_index = <span class="number">2</span>*root + <span class="number">1</span></span><br><span class="line">    right_node_index = <span class="number">2</span>*root + <span class="number">2</span></span><br><span class="line">    Max = root</span><br><span class="line">    <span class="comment"># 判断是否当前节点还有子节点, 判断左右节点和根结点的谁大</span></span><br><span class="line">    <span class="keyword">if</span> left_node_index &lt; heap_size <span class="keyword">and</span> heap[left_node_index] &gt; heap[Max]:</span><br><span class="line">        Max = left_node_index</span><br><span class="line">    <span class="keyword">if</span> right_node_index &lt; heap_size <span class="keyword">and</span> heap[right_node_index] &gt; heap[Max]:</span><br><span class="line">        Max = right_node_index</span><br><span class="line">    <span class="keyword">if</span> Max != root:</span><br><span class="line">        <span class="comment"># 如果左右节点比根节点大, 那么就更换根节点</span></span><br><span class="line">        heap[Max], heap[root] = heap[root], heap[Max]</span><br><span class="line">        max_heapify(heap, heap_size, Max) <span class="comment"># 继续判断当前根结点是否比左右节点大了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_max_heap</span>(<span class="params">heap</span>):</span></span><br><span class="line">    heap_size = <span class="built_in">len</span>(heap)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(heap_size//<span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 最终循环结束构建了一个顶大堆</span></span><br><span class="line">        max_heapify(heap, heap_size, i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">heap</span>):</span></span><br><span class="line">    build_max_heap(heap) <span class="comment"># 构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heap) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 前面已经键好了大顶堆, 接着需要把第一个元素和最后一个元素对换位置</span></span><br><span class="line">        heap[<span class="number">0</span>], heap[i] = heap[i], heap[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 不断的构造大顶堆, 然后把最大值放到堆底, i--</span></span><br><span class="line">        max_heapify(heap, i, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># print(heap)</span></span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(heap_sort(nums))</span><br></pre></td></tr></tbody></table></figure></code></pre>
]]></content>
      <categories>
        <category>Sorted</category>
      </categories>
      <tags>
        <tag>Sorted</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot_helloworld</title>
    <url>/2021/03/01/SpringBoot-helloworld/</url>
    <content><![CDATA[<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><hr>
<ol>
<li>maven-3.6.3 - <a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></li>
<li>Java/jdk-1.8.0_261 </li>
<li>IntelliJ Idea - Utimate<br> <strong>官方资料</strong><br> <a href="https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/getting-started.html#getting-started-system-requirements">https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/getting-started.html#getting-started-system-requirements</a></li>
</ol>
<h3 id="SprintBoot2入门"><a href="#SprintBoot2入门" class="headerlink" title="SprintBoot2入门"></a>SprintBoot2入门</h3><hr>
<ol>
<li><strong>maven设置</strong><ul>
<li>首先往/usr/local/maven-3.6.3/conf/settings.xml里面添加以下代码:<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用阿里云镜像, 便于下载依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jdk1.8进行项目编译 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><strong>开发第一个SpringBoot应用</strong><ul>
<li>(1) Creating the POM = 创建一个maven工程<ul>
<li>使用 “IntelliJ IDEA - Configure - settings - Build,Exception,Deployment - Build Tools - Maven”.</li>
<li>第一次需要把“Maven home directory 和 User settings file 和 Local repository”里面的地址改成我们自己下的maven而不是默认.</li>
</ul>
</li>
<li>(2) 使用SpringBoot开发,需要往项目的pom.xml里引入以下代码:  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    ```  </span><br><span class="line">* (3) 添加系统依赖, 往pom.xml写入以下代码, 此过程需要一点时间(可看Idea下面的进度条), 下载完成后在左边的Extemal Libraries里面会有很多额外倒入的包, 几乎包括所有的功能.</span><br><span class="line">    ```xml</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ```  </span><br><span class="line">* (4) 开始写代码, 首先是一个main主类,主方法:</span><br><span class="line">    ```java</span><br><span class="line">    // main 引导springboot程序启动</span><br><span class="line">    package org.example.boot;</span><br><span class="line">    import org.springframework.boot.SpringApplication;</span><br><span class="line">    import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">    /**</span><br><span class="line">    * 主程序类</span><br><span class="line">    * @SpringBootApplication: 这是一个springboot应用</span><br><span class="line">    */</span><br><span class="line">    @SpringBootApplication</span><br><span class="line">    public class MainApplication {</span><br><span class="line">        public static void main(String [] args) {</span><br><span class="line">            SpringApplication.run(MainApplication.class,args);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Controller 输入hello, 返回Hello,...</span></span><br><span class="line"><span class="keyword">package</span> org.example.boot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/hello")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, Spring Boot 2!"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>完成以上配置之后, 直接运行main文件可以看到以下内容:  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">23</span>:<span class="number">35</span>:<span class="number">38.127</span>  INFO <span class="number">14461</span> --- [           main] org.example.boot.MainApplication         : Starting MainApplication using Java <span class="number">1.8</span><span class="number">.0_261</span> with PID <span class="number">14461</span> (/Users/luyanxia/IdeaProjects/boot-<span class="number">01</span>-helloworld/target/classes started by luyanxia in /Users/luyanxia/IdeaProjects/boot-<span class="number">01</span>-helloworld)</span><br><span class="line"><span class="number">2021</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">23</span>:<span class="number">35</span>:<span class="number">38.133</span>  INFO <span class="number">14461</span> --- [           main] org.example.boot.MainApplication         : No active profile set, falling back to <span class="keyword">default</span> profiles: <span class="keyword">default</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">23</span>:<span class="number">35</span>:<span class="number">41.576</span>  INFO <span class="number">14461</span> --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : <span class="function">Tomcat initialized with <span class="title">port</span><span class="params">(s)</span>: 8888 <span class="params">(http)</span></span></span><br><span class="line"><span class="function">2021-02-28 23:35:41.590  INFO 14461 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span></span><br><span class="line"><span class="function">2021-02-28 23:35:41.590  INFO 14461 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.43]</span></span><br><span class="line"><span class="function">2021-02-28 23:35:41.749  INFO 14461 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span></span><br><span class="line"><span class="function">2021-02-28 23:35:41.750  INFO 14461 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3067 ms</span></span><br><span class="line"><span class="function">2021-02-28 23:35:42.079  INFO 14461 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'</span></span><br><span class="line"><span class="function">2021-02-28 23:35:42.494  INFO 14461 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on <span class="title">port</span><span class="params">(s)</span>: 8080 <span class="params">(http)</span> with context path ''</span></span><br><span class="line"><span class="function">2021-02-28 23:35:42.510  INFO 14461 --- [           main] org.example.boot.MainApplication         : Started MainApplication in 5.212 <span class="title">seconds</span> <span class="params">(JVM running <span class="keyword">for</span> <span class="number">6.411</span>)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这是表示Tomcat已启动端口8080, 可以在地址栏输入localhost:8080/hello, 如果成功则会返回Hello,…, 但是如果没成功则很有可能是controller创建到错误的位置了, 正确的位置如下:<div align="center"><img width="500" height="300" src="/images/Localhost_problem.png"></div></li>
<li>关于端口还可以在项目目录下的/src/main/resources里创建一个application.properties文件专门用来更改端口号, 并且还可以修改其他配置, 简化了配置过程:   <figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">            <span class="comment">// 端口号修改为8888</span></span><br><span class="line">            server.port = <span class="number">8888</span></span><br><span class="line">            ```  </span><br><span class="line"><span class="number">3.</span> **创建一个可执行的Jar包**</span><br><span class="line">    * 首先需要引入springboot已经提供的插件, 需要往pom.xml里面添加以下代码:</span><br><span class="line">        ```xml</span><br><span class="line">        &lt;build&gt;</span><br><span class="line">            &lt;plugins&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;/plugin&gt;</span><br><span class="line">            &lt;/plugins&gt;</span><br><span class="line">        &lt;/build&gt;</span><br></pre></td></tr></tbody></table></figure>
把整个项目打包成一个Jar包, 并且该Jar已经包含了所需的所有运行环境。点击右边的 “maven-项目名-lifecycle-package”,最后运行, 打包需要等待一段时间.<br>我们可以看到在该项目的目录下的target文件里包含了一个jar, 然后在target目录下运行终端并输入指令 “java -jar jar名称”, 这时我们也可以看到项目被成功启动, 并且可以通过特定端口进行访问.</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot_new_web</title>
    <url>/2021/03/05/SpringBoot-new-web/</url>
    <content><![CDATA[<h3 id="静态资源目录"><a href="#静态资源目录" class="headerlink" title="静态资源目录"></a>静态资源目录</h3><ol>
<li>静态资源需要放在类路径下: By default, Spring Boot serves static content from a directory called <strong>/static (or /public or /resources or /META-INF/resources)</strong> in the classpath or from the root of the ServletContext.<ul>
<li>注意: 如果在Controller也有和静态资源相同的命名资源, 那么请求会先访问Controller后去静态资源找, 若前两者都没有则返回404.</li>
</ul>
</li>
<li>可以自己指定静态路径, 以下代码添加在自己创建的.yaml文档(编辑配置文件, 和.properties一样)里, 作用是指定/static目录下的资源为静态资源, 且访问时需要在前面加上访问前缀/res(为了更好的搜索到目标文件), 这样的话之前1中的其他类路径就访问不到静态资源了:<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="comment"># 指定静态路径前需要加/res, 访问前缀</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="comment"># 指定静态路径为/static</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/static</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="Welcome-Page"><a href="#Welcome-Page" class="headerlink" title="Welcome Page"></a>Welcome Page</h3><ol>
<li><strong>方法一</strong>: 在静态资源下放置一个<strong>index.html</strong>文件. <ul>
<li>可以自己配置静态资源路径且添加前缀</li>
</ul>
</li>
<li><strong>方法二</strong>: controller里处理请求 <strong>/index</strong>.</li>
</ol>
<h3 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h3><ol>
<li>根据官方文档, 只需要在静态资源路径下放置名为<strong>favicon.ico</strong>的图片就会更改网页的图标.</li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-IO</title>
    <url>/2021/03/05/java_IO/</url>
    <content><![CDATA[<p><strong></strong></p><center><strong>InputStream &amp; OutputStream</strong></center><p></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<ol>
<li>明确要操作的数据是数据源(<strong>读</strong>)还是数据目的(<strong>写</strong>)</li>
<li>明确要操作的数据是字节还是文本<ul>
<li>InputStream - Reader</li>
<li>OutputStream - Writer</li>
</ul>
</li>
<li>明确数据所在的具体设备<ul>
<li>源<ul>
<li>硬盘：文件File</li>
<li>内存：数组，字符串</li>
<li>键盘：System.in</li>
<li>网络：Socket</li>
</ul>
</li>
<li>目的<ul>
<li>硬盘：文件File</li>
<li>内存：数组，字符串</li>
<li>屏幕：System.out</li>
<li>网络：Socket</li>
</ul>
</li>
</ul>
</li>
<li>明确是否需要额外功能 (转换流/高效流等)</li>
</ol>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-OOP</title>
    <url>/2021/01/30/java_oop/</url>
    <content><![CDATA[<p><strong></strong></p><center><strong>面向对象 - 分工而治, 统一管理</strong></center><p></p>
<h3 id="一-三大特性"><a href="#一-三大特性" class="headerlink" title="一.三大特性"></a>一.三大特性</h3><hr>
<ol>
<li><strong>封装 Encapsulation</strong><ul>
<li>提高程序安全性，保护数据</li>
<li>类的信息隐藏与内部且不能被直接访问 - private </li>
<li>可通过特定的方法实现隐藏信息的访问，统一接口 - 设置get和set方法</li>
</ul>
</li>
</ol>
<ol start="2">
<li><strong>继承 Inheritance</strong>   <ul>
<li>super 调用父类的构造方法，且只在子类的方法或者构造方法中</li>
<li>类与类之间的关系 - 父类(基类) - 子类(派生), 子类继承父类所有属性和方法, 父类不能调用子类的东西。</li>
<li>extends - 只能继承一个父类, <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">F</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure></li>
<li>子类不可继承构造方法(若要继承, 可使用super() - 表上一级&amp;父类, 置于子类构造方法内第一行)。</li>
<li><strong>方法 重写</strong><ul>
<li>为什么需要重写？ - 父类的方法也许子类不需要，或者不满足 </li>
<li>父类的成员方法只能被继承他的子类重写 <strong>“@override”</strong>。</li>
<li>重写的成员方法无论是参数还是返回类型(也可设置为子类类型)都必须与被重写方法相同。</li>
<li>子类中重写方法的访问权限应该 &gt;= 父类中被重写方法的权限, 访问修饰符 -&gt; **’public, protected, default, private’**，由左往右权限越来越低。  </li>
<li>final 和 static 本质不能被重写。</li>
<li>静态方法属于类(B b = new A() –&gt; B)，非静态方法属于对象(B b = new A() –&gt; A)</li>
</ul>
</li>
<li><strong>final</strong><ul>
<li>置于类前则不能被继承, 方法前则不能被重写, 变量前则不能被改变, 赋值前代表构造函数或者构造代码块。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><strong>多态 Professionaly</strong> <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//父类可以指向子类，但是不能调用子类独有方法</span></span><br><span class="line">Father object = <span class="keyword">new</span> Child() </span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>先继承, 再重写, 后才有多态,  相同的事物, 调用其相同的方法且参数也相同时, 但表现的行为却不同。</li>
<li>不同子类继承同一父类, 结果对同一方法的重写可以表现出不同的行为。</li>
<li>子转父，向上转型，自动转换，会丢失子类的一些方法</li>
<li>父转子，向下转型，强制转换</li>
<li>多态方便了方法的调用，不用重复new新的方法，仅需要转型就可以使用不同的方法。</li>
</ul>
</li>
</ol>
<h3 id="二-接口-interface"><a href="#二-接口-interface" class="headerlink" title="二.接口 interface"></a>二.接口 interface</h3><hr>
<ul>
<li><p>定义常量：public static final， 定义方法：public abstract</p>
</li>
<li><p>接口不能被实例化且没有构造方法</p>
</li>
<li><p><strong>定义了一个接口, 只包含方法和常量, 且方法仅声明不需要实现。</strong> </p>
<pre><code class="java">//接口
public interface Inf { 
  void fun1; 
  void fun2 
}
//实现类
public class Temp implements Inf { 
  @Override
  public void fun1() {

  }

  @Override
  public void fun2() {

  }
}
//实现类中必须实现所有接口定义的方法, 否则报错。
//main函数中继承实现类的时候应该 " = new 对应的接口" 而不是实现类本身。</code></pre>
</li>
</ul>
<h3 id="三-抽象类-abstract"><a href="#三-抽象类-abstract" class="headerlink" title="三.抽象类 abstract"></a>三.抽象类 abstract</h3><hr>
<ul>
<li>abstract修饰的方法叫抽象方法, 其不能实例化。</li>
<li>有抽象方法则该类一定是抽象类。</li>
<li>子类继承抽象父类, 一定要实现所有父类的方法。</li>
</ul>
<hr>
<ul>
<li><strong>抽象类和接口的区别</strong>  <ul>
<li>抽象类 - 可以不包含抽象方法。</li>
<li>抽象类 - 被子类继承 ‘extends’, 接口要被子类 ‘implements’。</li>
<li>接口支持多继承（一个类可以实现多个接口）, 但是类只能继承一个。</li>
<li>事物本质 - 抽象类, 一种操作 - 接口</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-Error&amp;Exception</title>
    <url>/2021/03/10/java_error_exception/</url>
    <content><![CDATA[<p><strong></strong></p><center><strong>错误&amp;异常的发生与处理</strong></center><p></p>
<h3 id="错误-amp-异常的分类"><a href="#错误-amp-异常的分类" class="headerlink" title="错误&amp;异常的分类"></a>错误&amp;异常的分类</h3><hr>
<ol>
<li>检查性异常: 程序员无法预见，例如用户打开一个不存在的文件，这些异常在编译时不能被简单的忽略</li>
<li>运行时异常: 运行时异常是可能被程序员避免的异常，</li>
<li>错误: 错误不是异常，这已经脱离了程序员控制的问题，例如栈溢出，此时在编译中检查不到 </li>
</ol>
<h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><hr>
<ul>
<li>Java把异常当作对象来处理，定义了一个基类java.lang.Throwable作为所有异常的超类</li>
<li>在Java API中已经定义了许多异常类，这些异常类分为两大类，Error和Exception</li>
</ul>
<h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><hr>
<ol>
<li><strong>抛出异常</strong></li>
<li><strong>捕获异常</strong></li>
<li><strong>异常处理的关键字有</strong>: try, catch, finally, throw, throws</li>
<li><strong>主动抛出异常</strong>，例throw new ArithmeticException()主动抛出异常，一般在方法里主动抛出异常</li>
<li><strong>自定义异常</strong>，只需要继承Exception类即可。<ul>
<li>创建自定义异常</li>
<li>在方法中通过throw关键字抛出异常</li>
<li>如果在当前抛出异常的方法中处理异常，可以使用try-catch捕获并处理，</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建博客</title>
    <url>/2021/01/22/my-new-post/</url>
    <content><![CDATA[<h3 id="为什么要搭Blog？"><a href="#为什么要搭Blog？" class="headerlink" title="为什么要搭Blog？"></a>为什么要搭Blog？</h3><hr>
<p>其实这个想法一直都有, 只是总有别的事或者懒。现在为了更好的对自己学过的东西进行总结, 因此建了个博客把一些学习笔记详细并系统的记录下来, 这样也方便了自己学习和回顾。趁现在放假花了点时间把Blog搭起来了, 使用了框架Hexo+主题Next-Gemini, 先放到了Github的仓库然后为了个性化而绑定一个自己喜欢的域名。</p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><hr>
<p>使用开源项目博客框架Hexo搭建了个人博客在mac系统上, 主题是Next-Gemini。</p>
<ol>
<li><strong>Hexo下载初始化后包含的文件</strong>:<ul>
<li>_config.yml : 总体配置文件, 又被称为”站级配置文件”, 作用于整个blog站点</li>
<li>source : md源文件目录, 该文件夹存放了一些子目录文件夹, 例如_posts, about, categories等<ul>
<li>_posts : 存放blog文章, 文章基本都是由markdown语法来编写</li>
<li>categories : 存放分类, 例如文章的种类</li>
</ul>
</li>
<li>themes : 存放blog的主题, 例如本文使用的next<ul>
<li>默认主题是landscape</li>
<li>next 该主题包含以下文件:<ul>
<li>_config.yml : 主题配置文件</li>
<li>layout 构造html的模版</li>
<li>source 静态资源目录, css &amp; js</li>
</ul>
</li>
</ul>
</li>
<li>public : 存放html, css, js等文件</li>
<li>scaffolds : 存放了一些模版, 例如新建blog文章</li>
<li>node_modules : NodeJs 所依赖的包, 后期可添加插件</li>
<li>package-look.json : 支持NodeJs的包<br>Hexo最基本的功能是把markdown程序先翻译成JSON格式(JavaScript Object Notation)然后再生成html文件</li>
</ul>
</li>
<li><strong>Hexo一些常用的命令</strong><ul>
<li>hexo new page “ “ - 定义新文章 </li>
<li>hexo clean  - 清除缓存文件(db.json) 和 已生成的静态文件(public)</li>
<li>hexo generate - 预先生成静态文件, 例如html</li>
<li>hexo server - 在本地启动服务器, 将生成的html网页部署到本地服务器</li>
<li>hexo deploy - 部署网站, 将生成的html网页代码推送到github<br>常用的缩写 “hexo clean &amp;&amp; hexo g &amp;&amp; hexo s” 适用于调试网页时在本地(localhost:4000)查看网页效果, 而 “hexo clean &amp;&amp; hexo g &amp;&amp; hexo d” 是部署到所有人都可以访问的网站上(本文购买了Namecheap的域名). 其实不购买域名也可以, 放到github上也能够被所有人访问到, 但是访问地址后缀是.github.io, 所以为了特别点还是要花点钱<br>通过学习他人的文章或者视频, 搭建博客以及绑定域名等都不是问题. 同时, 配置一些基础的功能,例如统计文章字数, 记录文章浏览人数, 网站建站时常等, 这些都不需要什么编程的基础就能够很快实现, 同时有任何问题都可以通过关键字搜到解决办法.<br>但是为了更好的了解hexo这个开源项目, 我们还是需要深入学习html和css和js, 这样无论是更改css样式还是调整网页的布局都更高效.  </li>
</ul>
</li>
</ol>
<h3 id="如何调试样式？"><a href="#如何调试样式？" class="headerlink" title="如何调试样式？"></a>如何调试样式？</h3><hr>
<p>hexo原始的框架基本已经提供了所有我们需要的样式, 我们需要做的就是在这个基础上设计我们自己喜欢的布局。我们可以通过快捷键 “fn+f12” 打开控制台, 这时我们能够看到控制台的工具栏有Elements, Console, Sources,…, Application这些标签页,在这里我们使用最多的就是Elements - 查看网页的HTML和CSS, 左边的呈现的是HTML结构, 右边是当前指定元素下的CSS样式, 这时我们能够通过修改这两个结构的值来直接观察网页的变化, 并且定位到我们想修改的地方(节省不少时间, 因为样式文件有很多)。</p>
<h3 id="gt-gt-碰到的问题"><a href="#gt-gt-碰到的问题" class="headerlink" title=">> 碰到的问题"></a>&gt;&gt; 碰到的问题</h3><hr>
<p>值得一提的是, 在调试blog的时候突然出现了一个错误:</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Custom layer</span></span><br><span class="line">   <span class="comment">// ----------------------------------------------</span></span><br><span class="line">   <span class="keyword">for</span> $inject_style <span class="keyword">in</span> hexo-config(<span class="string">'injects.style'</span>)</span><br><span class="line">       @<span class="keyword">import</span> $inject_style;</span><br></pre></td></tr></tbody></table></figure>
<p>然后整个网页变成没有样式的布局. 这个问题可以这样解决, 通过(<a href="https://blog.csdn.net/qq_52116176/article/details/109406842">https://blog.csdn.net/qq_52116176/article/details/109406842</a>): </p>
<ol>
<li>先在 “themes/next/source/css” 里面创建一个 “_custom” 文件夹, 然后在该文件夹里面创建”style.styl” (这个文件的目的是让用户自己自定义一些样式, 在这里面的样式的优先级最高), 并且添加以下代码:<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> { </span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(/images/greek-vase.png);</span><br><span class="line">    background-repeat: repeat;// 设定背景图片重复填充</span><br><span class="line">    <span class="selector-tag">background-attachment</span>: <span class="selector-tag">fixed</span>;// 设置背景图片不随页面滚动</span><br><span class="line">    <span class="selector-tag">background-position</span>: ; // 设置背景图片位置为默认值</span><br><span class="line">    <span class="selector-tag">background-size</span>: <span class="selector-tag">cover</span> // 此时会保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>然后修改在 “themes/source/css/main.styl” 路径下的 “main.styl” 就能够更换blog的背景了, 并且网页也恢复了正常显示. <figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Custom Layer</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> $inject_style <span class="keyword">in</span> hexo-config(<span class="string">'injects.style'</span>)</span><br><span class="line">    <span class="comment">// @import $inject_style;</span></span><br><span class="line">    @<span class="keyword">import</span> <span class="string">"_custom/style.styl"</span>;</span><br></pre></td></tr></tbody></table></figure>


</li>
</ol>
<h3 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h3><hr>
<ul>
<li>Blog搭建很快, 毕竟不太需要什么基础, 而样式的设计&amp;布局则需要花时间去学习 ‘HTML, CSS, JS’。</li>
</ul>
<h3 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h3><hr>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/28128674">hexo的next主题个性化教程:打造炫酷网站</a></li>
<li><a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">Hexo搭建博客教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26625249?utm_source=qq&amp;utm_medium=social">GitHub+Hexo 搭建个人网站详细教程</a></li>
<li><a href="https://jmyblog.top/">谁把钱丢了</a></li>
</ol>
]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-Thread</title>
    <url>/2021/03/15/java_thread/</url>
    <content><![CDATA[<p><strong></strong></p><center><strong>进程，线程，同步，锁，池</strong></center><p></p>
<h3 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h3><hr>
<ol>
<li>在操作系统中运行的程序就是<strong>进程</strong>(系统资源分配的单位)，例微信，QQ，音乐播放器等，一个进程可以有多个线程，例视频中声音，图像和弹幕等</li>
<li>线程是CPU调度和执行的单位</li>
</ol>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><hr>
<ol>
<li><p><strong>继承Thread类</strong> </p>
<ul>
<li>重写run()方法，编写线程执行体</li>
<li>创建线程对象，调用start()方法启动线程, </li>
<li>等待CPU调度</li>
<li>注意：线程开启不一定立即执行，由CPU调度执行</li>
<li>子类继承Thread类具备多线程能力</li>
<li>启动线程: 子类对象.start()<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程方式一： 继承Thread类，重写run()方法，调用start()开启线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread01</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"---run---"</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//main线程，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个线程对象</span></span><br><span class="line">        TestThread01 testThread01 = <span class="keyword">new</span> TestThread01();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用start()方法开启线程</span></span><br><span class="line">        testThread01.start(); <span class="comment">// 两个线程交替执行，主线程和子线程并行交替执行</span></span><br><span class="line">        <span class="comment">//testThread01.run(); // 只有主线程一条执行路径，先执行run()然后再输出下面的语句</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"++main++"</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong>实现Runnable接口</strong></p>
<ul>
<li><p>定义类实现Runnable接口</p>
</li>
<li><p>重写run()方法，编写线程执行体</p>
</li>
<li><p>创建线程对象，调用start方法启动线程</p>
</li>
<li><p>实现接口Runnable具有多线程能力</p>
</li>
<li><p>启动线程: 传入目标对象+Thread对象.start()</p>
</li>
<li><p>优点: 可避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程方式2： 实现runnable接口，重写run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"--run--"</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//创建runnable接口的实现类对象</span></span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象，通过线程对象来开启我们的线程, 代理</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"++main++"</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><hr>
<ol>
<li><strong>创建</strong><ul>
<li><strong>Thread t = new thread()</strong>, 创建线程对象</li>
</ul>
</li>
<li><strong>就绪</strong><ul>
<li>当调用start()方法，线程立即进入就绪状态，但不意味着立即运行</li>
<li>当获得cpu资源时进入运行状态</li>
</ul>
</li>
<li><strong>运行</strong><ul>
<li>进入运行状态，线程才真正执行线程体的代码块</li>
<li>当释放cpu资源时进入就绪状态</li>
<li>用户输入线程休眠等进入阻塞状态</li>
<li>线程自然执行完毕或者外部干涉终止线程则进入死亡状态</li>
</ul>
</li>
<li><strong>阻塞</strong><ul>
<li>调用sleep，wait或同步锁定，线程进入阻塞状态，此时代码不往下执行</li>
<li>阻塞解除后重新进入就绪状态等待cpu调度</li>
</ul>
</li>
<li><strong>死亡</strong><ul>
<li>线程终端或者结束，一旦死亡不可再次启动</li>
</ul>
</li>
</ol>
<h3 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h3><hr>
<ul>
<li>函数式接口 Functional Interface<ul>
<li>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>对于函数是接口我们可以通过lambda表达式来创建该接口的对象</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket - Server&amp;Client</title>
    <url>/2021/03/12/python_socket/</url>
    <content><![CDATA[<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><hr>
<ol>
<li><p>服务器端</p>
<ul>
<li>socket() - 内核创建一个socket<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></tbody></table></figure></li>
<li>bind() - 把一个本地协议地址(127.0.0.1)和套接口(用户设定)绑定, 因为服务端需要绑定一个端口让客户端知道服务器使用的是哪个端口.<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">self.serverSocket.bind((self.serverAddress, self.serverPort))</span><br></pre></td></tr></tbody></table></figure></li>
<li>listen() - 监听, 当socket创建后, 它被默认为是主动套接口, 默认为马上要调用connect函数, 但是作为服务器是需要被动接受的, 内核将在该套接口接收来自client的请求. 多个请求时需要在缓冲区排队, 缓冲区即请求队列为10.<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">self.serverSocket.listen(<span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li>accept() - 从队列中获得一个客户端的连接请求, 此函数返回已经握手完成的连接的套接口, 此处的套接口不同于服务器开始创建的监听套接口, 此套接口是已经完成连接的套接口, 监听套接口只是用来监听.<br>注意: listen() 只是让套接字处于监听状态, 并没有接收请求. 接收请求需要使用 accept() 函数。<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">self.serverSocket.accept()</span><br></pre></td></tr></tbody></table></figure>
accept() <strong>返回一个新的套接字</strong>来和客户端通信, addr 保存了客户端的IP地址和端口号, 而 sock 是服务器端新的套接字.</li>
</ul>
</li>
<li><p>客户端</p>
<ul>
<li>socket() - 内核创建一个socket<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></tbody></table></figure></li>
<li>connect() - 客户端建立socket后, 需要用connect函数和服务端进行连接<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">self.clientSocket.connect((self.serverIp, self.serverPort))</span><br></pre></td></tr></tbody></table></figure>
完成1,2步即完成了三次握手, TCP连接建立.</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>socket</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-Note_1</title>
    <url>/2021/01/30/note-network-1/</url>
    <content><![CDATA[<h3 id="四种时延delay类型"><a href="#四种时延delay类型" class="headerlink" title="四种时延delay类型"></a>四种时延delay类型</h3><hr>
<blockquote>
<p>分组转换中的延迟,丢失和吞吐量理想状态是：希望因特网服务能够在任意两个end systems之间瞬间移动大量的数据而没有任何数据的丢失。</p>
</blockquote>
<ol>
<li><strong>nodal processing delay - 节点处理时延</strong><ul>
<li>检查分组首部和决定的将该分组导向何处所需要的时间是处理时延的一部分。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><strong>queuing delay - 排队时延</strong><ul>
<li>当分组在链路上等待传输时的情况。若该队列当前为空, 并且当前没有其他分组在传输, 那么该分组的queuing delay 时延为0。反之则大。在毫秒到微秒级。</li>
<li>a表示packet到达queue的的平均速率(pkt/s),R 是bit从queue中推出的速率(bps), 假设所有的packet都是由L bit组成，则bit到达queue的平均速率是La (bps), 最后, 若queue很大, 则可以容纳很多bit, 比率aL/R 被称为流量强度(traffic intensity), 一般aL/R是不能大于1。还有就是当N个分组同时到达queue时, 第一个packet无queuing delay, 第二个有L/R 的排队时延，第n个有(n-1)L/R。</li>
<li>因为queue的容量f是有限的, 所以traffic intensity 接近于1时queuing delay也不会趋向无穷大, 而是到达的packet发现一个满的queue的话, 由于没有地方存储, 则router会drop掉这个packet。因此一个节点的性能需要根据delay来衡量, 而且要根据packet loss的概率来度量。</li>
</ul>
</li>
</ol>
<ol start="3">
<li><strong>transmission delay - 传输时延(存储转发时延)</strong><ul>
<li>分组一般以先到先服务的方式传输, </li>
<li>L 比特表示分组的长度: packet length (bits), R: link bandwidth(bps) 表示从路由器A传到路由器B的链路传输速率。d(trans) = (L / R) 表示将所有分组的比特传输到链路所需要的时间, 一般传输时延在毫秒到微秒级。</li>
</ul>
</li>
</ol>
<ol start="4">
<li><strong>propagation delay - 传播时延</strong><ul>
<li>d: length of pysical link, s: propagation speed 速率范围是 ~2 x 10^8 m/s, 等于或略小于光速。传播速率取决于link physical media, d(prop) = d / s。</li>
<li>一个bit被推向链路, 该bit需要向路由器B传播, 从该链路的起点到路由器B传播所需要的时间是propagrtion delay。传播时延在毫秒的量级。</li>
</ul>
</li>
</ol>
<ol start="5">
<li><strong>Transmission delay 和 propagation delay 的区别</strong><ul>
<li>Transmission 是router将分组推出所需要的时间, 取决于分组 length 和 link 传输速率。</li>
<li>Propagation 是bit从一个router到另一个router的时间, 取决于两路由之间的距离和传播速率(取决于物理介质)。</li>
</ul>
</li>
</ol>
<h3 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h3><hr>
<ol>
<li><strong>因特网传输协议</strong><ul>
<li><strong>传输控制协议 TCP</strong> - 面向连接, 可靠的数据传输服务, 在握手后就在两个进程的socket之间建立一个TCP connection。 数据传输单位是: 报文段。</li>
<li><strong>用户数据协议 UDP</strong> - 不可靠的数据传输服务, 是一种轻量级运输层协议, 无连接的, 因此两个进程通信前没有握手过程, 并且当进程通过UDP套接字发送message，UDP不保证该message能够被接收进程接收到, 不仅如此，接收进程接收到的message也有可能是乱序到达的, 并且UDP没有拥塞控制, 所以发送端可以以任何速率向下面的层注入数据。数据传输单位是: 用户数据报。</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><p><strong>OSI七层模型以及TCP/IP五层模型</strong></p>
 <div align="center"><img width="300" height="300" src="/images/OSI_TCP.png"></div>

<ul>
<li><p>HTTP - Hyper test transfer protocol - 超文本传输协议,<br>SMTP - Simple message transfer protocol - 简单信息传输协议,<br>FTP - File transfer protocol - 文件传输协议,<br>UDP - User datagram protocol - 用户数据报协议</p>
</li>
<li><p><strong>(1) 应用层 Applications</strong> - FTP, HTTP, SMTP, SKYPE<br>HTTP(它为web文档提供了请求和传送)<br>SMTP(它提供了电子邮件报文的传输)<br>FTP(它提供了两个end-system之间的文件传送)<br>应用层协议分布在多个端系统上, 一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组, 我们将这种位于application的信息分组称为报文(message)。</p>
</li>
<li><p><strong>(2) 传输层 Transport</strong> - TCP, UDP<br>在因特网中, 有两个运输层协议, 将运输层分组称为报文段segment。</p>
</li>
<li><p><strong>(3) 网络层 Network</strong> - IP, 路由协议</p>
<ul>
<li>因特网的网络层负责把datagram的网络层分组从一台host移动到另一台host, 源host中的TCP或UDP向网络层递交transport层报文段segment(类似向邮政信件提供目的地址)。</li>
<li>网络层还包括了IP协议, 该协议定义了datagram中的各个字段以及end system和router如何做用于这些字段。因特网的network也包括决定router的选路协议, datagram根据该router从源host传到destination host。网络层也被称为IP层, 这反映了IP可以将因特网连接在一起。</li>
</ul>
</li>
<li><p><strong>(4) 链路层 Link</strong> - 以太网 Ethernet, 802.111(WI-FI), PPP<br>  为了把packet从一个节点(host或router)移动到路径上的下一个节点, network层需要链路层link的服务。帧(frame)</p>
</li>
<li><p><strong>(5) 物理层 Physical</strong> - bits 金属丝, 电线等</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
</search>
